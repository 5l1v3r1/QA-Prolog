{
// This is the parser for Quantum-Computing Prolog.  It was written using the
// Pigeon parser generator's DSL (https://github.com/PuerkitoBio/pigeon) and is
// inspired by the Prolog grammar found at
// https://github.com/simonkrenger/ch.bfh.bti7064.w2013.PrologParser/blob/master/doc/prolog-bnf-grammar.txt
// but with various bugs corrected and the grammar converted to a PEG.

package main

// An ASTNodeType indicates the type of AST node we're working with.
//go:generate stringer -type=ASTNodeType
type ASTNodeType int

// Declare all of the AST node types we intend to use.
const (
	UnknownType   ASTNodeType = iota // Should never be used
	NumeralType                      // Non-negative integer (e.g., "123")
	AtomType                         // Atom, with quotes stripped (e.g., "scott")
	VariableType                     // Variable (e.g., "Name")
	TermType                         // Term (a numeral, atom, or variable)
	TermListType                     // List of terms
	PredicateType                    // Predicate (e.g., "likes(john, mary)")
	StructureType                    // Structure (e.g., "likes(john, mary)")
)

// An ASTNode defines a single node in an abstract syntax tree.
type ASTNode struct {
	Type     ASTNodeType // What this node represents
	Value    interface{} // Node's value (int, string, etc.)
	Pos      position    // Node's position in the input file
	Children []*ASTNode  // Child AST node(s), if any
}

// String outputs an AST node and all its children, mostly for debugging.
func (a *ASTNode) String() string {
	result := ""
	var showAll func(*ASTNode, int)
	showAll = func(n *ASTNode, depth int) {
		// Display this node.
		indent := strings.Repeat("  ", depth)
		result += fmt.Sprintf("%sType:  %s\n", indent, n.Type)
		result += fmt.Sprintf("%sValue: %#v\n", indent, n.Value)
		result += fmt.Sprintf("%sPos:   %d:%d\n", indent, n.Pos.line, n.Pos.col)

		// Recursively display all children.
		for i, child := range n.Children {
			if i > 0 {
				result += "\n"
			}
			showAll(child, depth+1)
		}
	}
	showAll(a, 0)
	return result
}

// This is a temporary main() for testing the parser.
func main() {
    if len(os.Args) != 2 {
        log.Fatalf("Usage: %s <text>", os.Args[0])
    }
    got, err := ParseReader("", strings.NewReader(os.Args[1]))
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(got)
}

}

Temporary_test <- whatever:Predicate EOF {
	return fmt.Sprintf("%s", whatever), nil
}

// Return an AST node of type PredicateType.
Predicate <- atom:Atom WS* '(' WS* tl:TermList WS* ')' {
	node := ASTNode{
		Type:     PredicateType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{atom.(*ASTNode), tl.(*ASTNode)},
	}
	return &node, nil
} / atom:Atom {
	node := ASTNode{
		Type:     PredicateType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{atom.(*ASTNode)},
	}
	return &node, nil
}

// Return an AST node of type TermList.
TermList <- first:Term WS* "," WS* rest:TermList {
	// Prepend a Term onto an existing TermList.
	termNode := first.(*ASTNode)
	termListNode := rest.(*ASTNode)
	node := ASTNode{
		Type:     TermListType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: append([]*ASTNode{termNode}, termListNode.Children...),
	}
	return &node, nil
} / only:Term {
	// Return a TermList containing a single Term.
	termNode := only.(*ASTNode)
	node := ASTNode{
		Type:     TermListType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{termNode},
	}
	return &node, nil
}

// Return an AST node of type TermType.
Term <- child:(Numeral / Structure / Atom / Variable) {
	childNode := child.(*ASTNode)
	node := ASTNode{
		Type:     TermType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{childNode},
	}
	return &node, nil
}

// Return an AST node of type StructureType.
Structure <- atom:Atom WS* '(' WS* tl:TermList WS* ')' {
	node := ASTNode{
		Type:     StructureType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{atom.(*ASTNode), tl.(*ASTNode)},
	}
	return &node, nil
}

// Return an AST node of type VariableType.
Variable <- Uppercase_letter Symbol_trailer {
	node := ASTNode{
		Type:  VariableType,
		Value: string(c.text),
		Pos:   c.pos,
	}
	return &node, nil
}

// Return an AST node of type AtomType.
Atom <- Small_atom {
	node := ASTNode{
		Type:  AtomType,
		Value: string(c.text),
		Pos:   c.pos,
	}
	return &node, nil
} / Single_quoted_string {
	s := string(c.text)
	node := ASTNode{
		Type:  AtomType,
		Value: s[1 : len(s)-1],
		Pos:   c.pos,
	}
	return &node, nil
}

Single_quoted_string <- "'" Single_quoted_string_char* "'"

Single_quoted_string_char <- Character / '\\' .

Small_atom <- Lowercase_letter Symbol_trailer {
	return string(c.text), nil
}

Symbol_trailer <- (Lowercase_letter / Uppercase_letter / Digit)*

Character <- Lowercase_letter / Uppercase_letter / Digit / Not_single_quote

Lowercase_letter <- [\p{Ll}]

Uppercase_letter <- [\p{Lu}_]

Digit <- [\p{Nd}]

WS <- [\p{Zs}\n\r\t]

// Return an AST node of type NumeralType.
Numeral <- Digit+ {
	num, err := strconv.Atoi(string(c.text))
	if err != nil {
		return nil, err
	}
	node := ASTNode{
		Type:  NumeralType,
		Value: num,
		Pos:   c.pos,
	}
	return &node, nil
}

Not_single_quote <- [^']

EOF <- !.
