{
// This is the parser for Quantum-Computing Prolog.  It was written using the
// Pigeon parser generator's DSL (https://github.com/PuerkitoBio/pigeon) and is
// inspired by the Prolog grammar found at
// https://github.com/simonkrenger/ch.bfh.bti7064.w2013.PrologParser/blob/master/doc/prolog-bnf-grammar.txt
// but with various bugs corrected and the grammar converted to a PEG.

package main

// An ASTNodeType indicates the type of AST node we're working with.
//go:generate stringer -type=ASTNodeType
type ASTNodeType int

// Declare all of the AST node types we intend to use.
const (
	UnknownType       ASTNodeType = iota // Should never be used
	NumeralType                          // Non-negative integer (e.g., "123")
	AtomType                             // Atom, with quotes stripped (e.g., "scott")
	VariableType                         // Variable (e.g., "Name")
	TermType                             // Term (a numeral, atom, or variable)
	TermListType                         // List of terms
	PredicateType                        // Predicate (e.g., "likes(john, mary)")
	StructureType                        // Structure (e.g., "likes(john, mary)")
	PredicateListType                    // List of predicates (e.g., "likes(john, X), likes(X, mary)")
)

// An ASTNode defines a single node in an abstract syntax tree.
type ASTNode struct {
	Type     ASTNodeType // What this node represents
	Value    interface{} // Node's value (int, string, etc.)
	Pos      position    // Node's position in the input file
	Children []*ASTNode  // Child AST node(s), if any
}

// String outputs an AST node and all its children, mostly for debugging.
func (a *ASTNode) String() string {
	result := ""
	var showAll func(*ASTNode, int)
	showAll = func(n *ASTNode, depth int) {
		// Display this node.
		indent := strings.Repeat("  ", depth)
		result += fmt.Sprintf("%sType:  %s\n", indent, n.Type)
		result += fmt.Sprintf("%sValue: %#v\n", indent, n.Value)
		result += fmt.Sprintf("%sPos:   %d:%d\n", indent, n.Pos.line, n.Pos.col)

		// Recursively display all children.
		for i, child := range n.Children {
			if i > 0 {
				result += "\n"
			}
			showAll(child, depth+1)
		}
	}
	showAll(a, 0)
	return result
}

// This is a temporary main() for testing the parser.
func main() {
    if len(os.Args) != 2 {
        log.Fatalf("Usage: %s <text>", os.Args[0])
    }
    got, err := ParseReader("", strings.NewReader(os.Args[1]))
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println(got)
}

}

Temporary_test <- whatever:PredicateList EOF {
	return fmt.Sprintf("%s", whatever), nil
}

// Return an AST node of type PredicateListType.
PredicateList <- p:Predicate Skip ',' Skip ps:PredicateList {
	// Prepend a Predicate onto an existing PredicateList.
	predNode := p.(*ASTNode)
	predListNode := ps.(*ASTNode)
	node := ASTNode{
		Type:     PredicateListType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: append([]*ASTNode{predNode}, predListNode.Children...),
	}
	return &node, nil
} / p:Predicate {
	// Return a PredicateList containing a single Predicate.
	node := ASTNode{
		Type:     PredicateListType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: append([]*ASTNode{p.(*ASTNode)}),
	}
	return &node, nil
}

// Return an AST node of type PredicateType.
Predicate <- atom:Atom Skip '(' Skip tl:TermList Skip ')' {
	node := ASTNode{
		Type:     PredicateType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{atom.(*ASTNode), tl.(*ASTNode)},
	}
	return &node, nil
} / atom:Atom {
	node := ASTNode{
		Type:     PredicateType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{atom.(*ASTNode)},
	}
	return &node, nil
}

// Return an AST node of type TermList.
TermList <- first:Term Skip "," Skip rest:TermList {
	// Prepend a Term onto an existing TermList.
	termNode := first.(*ASTNode)
	termListNode := rest.(*ASTNode)
	node := ASTNode{
		Type:     TermListType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: append([]*ASTNode{termNode}, termListNode.Children...),
	}
	return &node, nil
} / only:Term {
	// Return a TermList containing a single Term.
	termNode := only.(*ASTNode)
	node := ASTNode{
		Type:     TermListType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{termNode},
	}
	return &node, nil
}

// Return an AST node of type TermType.
Term <- child:(Numeral / Structure / Atom / Variable) {
	childNode := child.(*ASTNode)
	node := ASTNode{
		Type:     TermType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{childNode},
	}
	return &node, nil
}

// Return an AST node of type StructureType.
Structure <- atom:Atom Skip '(' Skip tl:TermList Skip ')' {
	node := ASTNode{
		Type:     StructureType,
		Value:    string(c.text),
		Pos:      c.pos,
		Children: []*ASTNode{atom.(*ASTNode), tl.(*ASTNode)},
	}
	return &node, nil
}

// Return an AST node of type VariableType.
Variable <- Uppercase_letter Symbol_trailer {
	node := ASTNode{
		Type:  VariableType,
		Value: string(c.text),
		Pos:   c.pos,
	}
	return &node, nil
}

// Return an AST node of type AtomType.
Atom <- Small_atom {
	node := ASTNode{
		Type:  AtomType,
		Value: string(c.text),
		Pos:   c.pos,
	}
	return &node, nil
} / Single_quoted_string {
	s := string(c.text)
	node := ASTNode{
		Type:  AtomType,
		Value: s[1 : len(s)-1],
		Pos:   c.pos,
	}
	return &node, nil
}

Single_quoted_string <- "'" Single_quoted_string_char* "'"

Single_quoted_string_char <- Character / '\\' .

Small_atom <- Lowercase_letter Symbol_trailer {
	return string(c.text), nil
}

Symbol_trailer <- (Lowercase_letter / Uppercase_letter / Digit)*

Character <- Lowercase_letter / Uppercase_letter / Digit / Not_single_quote

Lowercase_letter <- [\p{Ll}]

Uppercase_letter <- [\p{Lu}_]

Digit <- [\p{Nd}]

WS <- [\p{Zs}\n\r\t]

One_line_comment <- '%' [^\n\r]* '\r'? '\n'

Multi_line_comment <- "/*" (Multi_line_comment / '*' !'/' / [^*])* "*/"

// Skip represents material to ignore, specifically whitespace and comments.
Skip <- (WS / One_line_comment / Multi_line_comment)*

// Return an AST node of type NumeralType.
Numeral <- Digit+ {
	num, err := strconv.Atoi(string(c.text))
	if err != nil {
		return nil, err
	}
	node := ASTNode{
		Type:  NumeralType,
		Value: num,
		Pos:   c.pos,
	}
	return &node, nil
}

Not_single_quote <- [^']

EOF <- !.
